/*     ____ ____  ____ ____  ______                                     *\
**    / __// __ \/ __// __ \/ ____/    SOcos COmpiles Scala             **
**  __\_ \/ /_/ / /__/ /_/ /\_ \       (c) 2002, 2003, 2004, LAMP/EPFL  **
** /_____/\____/\___/\____/____/                                        **
**                                                                      **
** $Id$
\*                                                                      */

package scalac.symtab.classfile;

import scala.tools.util.Position;
import scalac.util.Name;
import scalac.symtab.Modifiers;
import scalac.symtab.Symbol;
import scalac.symtab.Scope;
import scalac.symtab.Type;
import scalac.ApplicationError;
import scalac.util.Debug;

import java.util.Vector;
import java.util.StringTokenizer;
import java.util.NoSuchElementException;

/** a parser class for parsing meta type information in classfiles
 *  generated by pico.
 */
class MetaParser {
    private final Symbol owner;
    private final StringTokenizer scanner;
    private final Type defaultType;
    private String token;
    private final Scope tvars;
    private Scope locals;
    private final Symbol clazz;
    private final Type ctype;
    private final JavaTypeFactory make;

    MetaParser(String meta, Scope tvars, Symbol owner, Type defaultType,
               Symbol clazz, Type ctype, JavaTypeFactory make) {
        this.scanner = new StringTokenizer(meta, "()[], \t<;", true);
        this.defaultType = defaultType;
        this.owner = owner;
        this.tvars = tvars;
        this.clazz = clazz;
        this.ctype = ctype;
        this.make = make;
    }

    private static Name getTypeName(String name) {
        return Name.fromString(name).toTypeName();
    }

    private Symbol getTVar(String name) {
        return getTVar(name, clazz.primaryConstructor());
    }

    private Symbol getTVar(String name, Symbol owner) {
        if (name.startsWith("?")) {
            Symbol s = (locals != null ? locals : tvars)
                .lookup(getTypeName(name));
            if (s != Symbol.NONE)
                return s;
            else if (locals != null) {
                s = tvars.lookup(getTypeName(name));
                if (s != Symbol.NONE)
                    return s;
            }
            s = owner.newTParam
                (Position.NOPOS, 0, getTypeName(token), make.anyType());
            tvars.enter(s);
            return s;
        } else
            return Symbol.NONE;
    }

    private String nextToken() {
        do {
            token = scanner.nextToken().trim();
        } while (token.length() == 0);
        return token;
    }

    protected Type parse() {
        if (scanner.hasMoreTokens()) {
            nextToken();
            if (!scanner.hasMoreTokens())
                return defaultType;
            if ("class".equals(token))
                return parseMetaClass();
            if ("method".equals(token))
                return parseMetaMethod();
            if ("field".equals(token))
                return parseMetaField();
            if ("constr".equals(token))
                return parseConstrField();
        }
        return defaultType;
    }

    protected Type parseMetaClass() {
        nextToken();
        //System.out.println("parse meta class " + token);//DEBUG
        if ("[".equals(token)) {
            try {
                Vector syms = new Vector();
                do {
                    nextToken();
                    int vflag = 0;
                    if (token.equals("+")) {
                        nextToken();
                        vflag = Modifiers.COVARIANT;
                    } else if (token.equals("-")) {
                        nextToken();
                        vflag = Modifiers.CONTRAVARIANT;
                    }
                    assert token.startsWith("?");
                    Symbol s = getTVar(token);
                    if (s == Symbol.NONE)
                        return defaultType;
                    s.flags |= vflag;
                    nextToken();
                    //System.out.println("new var " + s + ", " + token);//DEBUG
                    if (token.equals("<")) {
                        nextToken();
                        s.setInfo(parseType());
                    }
                    syms.add(s);
                } while (token.equals(","));
                assert "]".equals(token);
                nextToken();
                Symbol[] smbls = (Symbol[])syms.toArray(new Symbol[syms.size()]);
                //System.out.println("*** " + syms);//DEBUG
                Type clazztype = Type.appliedType(ctype, Symbol.type(smbls));
                Symbol constr = clazz.primaryConstructor();
                switch (constr.rawInfo()) {
                case MethodType(Symbol[] vparams, _):
                    constr.setInfo(Type.PolyType
                                   (smbls, Type.MethodType(vparams, clazztype)));
                    break;
                default:
                    throw new ApplicationError(constr.rawInfo());
                }
            } catch (NoSuchElementException e) {
            }
        }
        Type res = defaultType;
        if ("extends".equals(token)) {
            Vector basetpes = new Vector();
            do {
                nextToken();
                basetpes.add(parseType());
            } while (token.equals("with"));
            switch (defaultType) {
            case CompoundType(_, Scope scope):
                Type[] ts = (Type[])basetpes.toArray(new Type[basetpes.size()]);
                res = Type.compoundType(ts, scope, defaultType.symbol());
            }
        }
        assert ";".equals(token);
        return res;
    }

    protected Type parseType() {
        String name = token;
        Symbol s = getTVar(name);
        nextToken();
        if (s != Symbol.NONE)
            return s.type();
        Type clazztype = make.classType(name).unalias();
        if (token.equals("[")) {
            Vector types = new Vector();
            do {
                nextToken();
                types.add(parseType());
            } while (token.equals(","));
            assert "]".equals(token);
            nextToken();
            Type[] args = new Type[types.size()];
            types.toArray(args);
            return Type.appliedType(clazztype, args);
        } else {
            return clazztype;
        }
    }

    protected Type parseMetaMethod() {
        locals = new Scope();
        try {
            nextToken();
            Symbol[] smbls = null;
            //System.out.println("parse meta method " + token);
            if ("[".equals(token)) {
                Vector syms = new Vector();
                do {
                    nextToken();
                    if ("]".equals(token))
                        break;
                    assert token.startsWith("?");
                    Symbol s = owner.newTParam
                        (Position.NOPOS, 0, getTypeName(token), make.anyType());
                    locals.enter(s);
                    nextToken();
                    if (token.equals("<")) {
                        nextToken();
                        s.setInfo(parseType());
                    }
                    syms.add(s);
                } while (token.equals(","));
                assert "]".equals(token);
                nextToken();
                smbls = (Symbol[])syms.toArray(new Symbol[syms.size()]);
            }
            if ("(".equals(token)) {
                int i = 0;
                Vector params = new Vector();
                do {
                    nextToken();
                    if (")".equals(token))
                        break;
                    int flags = 0;
                    if ("def".equals(token)) {
                        nextToken();
                        flags |= Modifiers.DEF;
                    }
                    Symbol vp = owner.newVParam
                        (Position.NOPOS, flags, Name.fromString("x" + (i++)));
                    params.add(vp.setInfo(parseType()));
                    //System.out.println("  + " + token);
                } while (token.equals(","));
                assert ")".equals(token);
                nextToken();
                //System.out.println("+++ method " + token);
                Type restpe = parseType();
                assert ";".equals(token);
                Type mtype = Type.MethodType
                    ((Symbol[])params.toArray(new Symbol[params.size()]),
                     restpe);
                return smbls == null ? mtype : Type.PolyType(smbls, mtype);
            } else {
                Type res = parseType();
                assert ";".equals(token);
                return Type.PolyType
                    (smbls == null ? Symbol.EMPTY_ARRAY : smbls, res);
            }
        } catch (NoSuchElementException e) {
            e.printStackTrace();
            return defaultType;
        } finally {
            locals = null;
        }
    }

    protected Type parseMetaField() {
        nextToken();
        return parseType();
    }

    protected Type parseConstrField() {
        try {
            nextToken();
            //System.out.println("+++ constr " + token);
            if ("(".equals(token)) {
                int i = 0;
                Vector params = new Vector();
                do {
                    nextToken();
                    if (")".equals(token))
                        break;
                    Symbol vp = owner.newVParam
                        (Position.NOPOS, 0, Name.fromString("x" + (i++)));
                    params.add(vp.setInfo(parseType()));
                    //System.out.println("  + " + token);
                } while (token.equals(","));
                assert ")".equals(token);
                nextToken();
                assert ";".equals(token);
                return Type.MethodType((Symbol[])params.toArray(new Symbol[params.size()]),
                                       ctype);
            } else {
                assert ";".equals(token);
                return Type.PolyType(Symbol.EMPTY_ARRAY, ctype);
            }
        } catch (NoSuchElementException e) {
            return defaultType;
        }
    }
}
