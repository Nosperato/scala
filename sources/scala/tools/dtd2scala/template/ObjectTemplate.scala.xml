<!DOCTYPE template [ 
  <!ENTITY elementName   '<string ref="elementName"/>'> 
  <!ENTITY qElementName  '<qstring ref="elementName"/>'> 
  <!ENTITY ccElementName '<ccstring ref="elementName"/>'> 
  <!ENTITY elementContentModel   '<string ref="elementContentModel"/>'> 
  <!ENTITY attributeName   '<string ref="attributeName"/>'> 
  <!ENTITY qAttributeName  '<qstring ref="attributeName"/>'> 
  <!ENTITY cAttributeName '<cstring ref="attributeName"/>'> 
  <!ENTITY space '<![CDATA[ ]]>'> 
  <!ENTITY br ''> 
]>
<!-- generalize to abstract syntax instead of concrete ? -->
<!-- the formatting should be done by a code beautifier -->
<template>
  /* this file is generated from a DTD using ObjectTemplate.scala.xml */
  <!-- package/ -->
  
  /** the following elements are bound
  <elementBinding>
    * &elementName; : &elementContentModel; {<attributeBinding>&attributeName;</attributeBinding>&space;}
  </elementBinding>
  **/
  
  object <string ref="objectName"/> {

    type childrenT = scala.Seq[scala.xml.Node];
    type attribMap  = scala.collection.immutable.Map[String,String];
    type attribMapT = scala.collection.mutable.HashMap[String,String];
    type NodeConstructorType = (childrenT,attribMapT) =&gt; scala.xml.Node;

    <elementBinding>
    def constr_&ccElementName;( ch:childrenT, attrs:attribMapT ) = new &ccElementName;(ch:_*) { 
      val aMap = scala.collection.immutable.ListMap.Empty[String,String].incl( attrs.toList );
      override def attributes : attribMap = aMap;
      <attributeBinding>
      override val &cAttributeName; = attrs.get(&qAttributeName;); 
      </attributeBinding>
      val attribHashCode: int = attrs.toList.hashCode() ;
    };
    
     case class &ccElementName;( ch:scala.xml.Node* ) extends scala.xml.AttributedNode {
          def label = &qElementName;; 
          def children = ch;

      override def attributes : attribMap = {
        var m = scala.collection.immutable.ListMap.Empty[String,String];
        <attributeBinding>
        this.&cAttributeName; match {
          case scala.Some( x ) => m.update( &qAttributeName;, x ); 
          case scala.None =>;  
        };
        </attributeBinding>
        m
      }

      <attributeBinding>
        val &cAttributeName; : scala.Option[String] = scala.None;  /* o'ridden at parse time */
      </attributeBinding>

      def % (attrs:scala.List[Pair[String,String]]) = new &ccElementName;( children:_* ) {

        private var lmap =  &ccElementName;.this.attributes.incl( attrs );
        override def attributes : attribMap = lmap;
        <attributeBinding>        
        override val &cAttributeName; = lmap.get(&qAttributeName;);
        </attributeBinding>        
      }

      def % (attr:Pair[String,String]) = new &ccElementName;( children:_* ) {

        private var lmap =  &ccElementName;.this.attributes.incl( attr );
        override def attributes : attribMap = lmap;
        <attributeBinding>        
        override val &cAttributeName; = lmap.get(&qAttributeName;);
        </attributeBinding>        
      }

    }
    </elementBinding>
    

    def load( filename:String ):scala.xml.Node = load( filename, <string ref="compressDefault"/> );

    def load( filename:String, _compress:boolean ):scala.xml.Node = {
      val fAdapter = new scala.xml.BindingFactoryAdapter  {
        val f = { 
          val res = new scala.collection.mutable.HashMap[String, NodeConstructorType] ;
          <elementBinding>
          res.update( &qElementName;, (x:childrenT,aMap:attribMapT) => constr_&ccElementName;(x,aMap));</elementBinding>
          res;
        }

        val g = { 
          val res = new scala.collection.mutable.HashMap[scala.String, boolean] ;
          <elementBinding>
          res.update( &qElementName;, <string ref="elementContainsText"/>);</elementBinding>
          res;
        }
        val compress = _compress ; 
      };
      fAdapter.loadXML( new org.xml.sax.InputSource(filename) );
    };    
}
</template>
