<!DOCTYPE template [ 
  <!ENTITY elementName   '<string ref="elementName"/>'> 
  <!ENTITY qElementName  '<qstring ref="elementName"/>'> 
  <!ENTITY ccElementName '<ccstring ref="elementName"/>'> 
  <!ENTITY elementContentModel   '<string ref="elementContentModel"/>'> 
  <!ENTITY attributeName   '<string ref="attributeName"/>'> 
  <!ENTITY qAttributeName  '<qstring ref="attributeName"/>'> 
  <!ENTITY cAttributeName '<cstring ref="attributeName"/>'> 
  <!ENTITY space '<![CDATA[ ]]>'> 
  <!ENTITY br ''> 
]>
<!-- generalize to abstract syntax instead of concrete ? -->
<!-- the formatting should be done by a code beautifier -->
<template>
  /* this file is generated from a DTD using ObjectTemplate.scala.xml */
  <!-- package/ -->
import org.xml.sax.InputSource;
import scala.xml._ ;&br;
import scala.collection.Map ;
import scala.collection.mutable.HashMap ;
  
  /** the following elements are bound
  <elementBinding>
    * &elementName; : &elementContentModel; {<attributeBinding>&attributeName;</attributeBinding>&space;}
  </elementBinding>
  **/
  
  object <string ref="objectName"/> {

    type childrenT = scala.Seq[scala.xml.Node];
    type attribMapT = HashMap[String,String];
    type NodeConstructorType = (childrenT,attribMapT) =&gt; scala.xml.Node;

    <elementBinding>
      def constr_&ccElementName;( ch:childrenT, attrs:attribMapT ) = 
    new &ccElementName;(ch:_*) { 
      def attributes : Map[String,String] = attrs;    
      <attributeAssign>    
      override val &cAttributeName; = attrs.get(&qAttributeName;); 
      </attributeAssign>
      val attribHashCode: int = attrs.toList.hashCode() ;
    };
    def &ccElementName;( ch:Node* ) = new &ccElementName;(ch:_*){
      def attributes = scala.collection.immutable.ListMap.Empty[String,String];
      val attribHashCode = 0;
    };
      abstract case class &ccElementName;( ch:Node* ) extends scala.xml.AttributedNode {
          def label = &qElementName;; 
          def children = ch;
      <attributeBinding>
        val &cAttributeName; : scala.Option[String] = scala.None;  /* o'ridden at parse time */
      </attributeBinding>
      }
    </elementBinding>
    

    def load( filename:String ):Node = load( filename, <string ref="compressDefault"/> );

    def load( filename:String, _compress:boolean ):scala.xml.Node = {
      val fAdapter = new BindingFactoryAdapter  {
        val f = { 
          val res = new HashMap[String, NodeConstructorType] ;
          <elementBinding>
          res.update( &qElementName;, (x:childrenT,aMap:attribMapT) => constr_&ccElementName;(x,aMap));</elementBinding>
          res;
        }

        val g = { 
          val res = new HashMap[scala.String, boolean] ;
          <elementBinding>
          res.update( &qElementName;, <string ref="elementContainsText"/>);</elementBinding>
          res;
        }
        val compress = _compress ; 
      };
      fAdapter.loadXML( new InputSource(filename) );
    };    
}
</template>
