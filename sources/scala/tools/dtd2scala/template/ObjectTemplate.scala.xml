<!DOCTYPE template [ 
  <!ENTITY elementName   '<string ref="elementName"/>'> 
  <!ENTITY qElementName  '<qstring ref="elementName"/>'> 
  <!ENTITY ccElementName '<ccstring ref="elementName"/>'> 
  <!ENTITY elementContentModel   '<string ref="elementContentModel"/>'> 
  <!ENTITY attributeName   '<string ref="attributeName"/>'> 
  <!ENTITY qAttributeName  '<qstring ref="attributeName"/>'> 
  <!ENTITY cAttributeName '<cstring ref="attributeName"/>'> 
  <!ENTITY space '<![CDATA[ ]]>'> 
  <!ENTITY br ''> 
]>
<!-- generalize to abstract syntax instead of concrete ? -->
<!-- the formatting should be done by a code beautifier -->
<template>
  /* this file is generated from a DTD using ObjectTemplate.scala.xml */
  <!-- package/ -->
  
  /** the following elements are bound
  <elementBinding>
    * &elementName; : &elementContentModel; {<attributeBinding>&attributeName;</attributeBinding>&space;}
  </elementBinding>
  **/
  
  object <string ref="objectName"/> {

    import scala.collection.Map;
    import scala.collection.immutable;
    import scala.collection.mutable;

    type cT = scala.Seq[scala.xml.Node];
    type aT = Map[String,String];

    def error_FixedAttribute( k:String, value:String ) =
      error("value of attribute " + k + " FIXED to \""+value+"\"");

    def error_UndefinedAttribute( b:String ) = 
      error("undefined attribute " + b );

    def error_MissingAttribute( map:aT ) =
      error("missing value for REQUIRED attribute "
                 +(map.keys.filter { x => map(x) == "&lt;R" })
                   .toList.mkString("",",",""));

    abstract class <string ref="objectName"/>Node$ extends scala.xml.Node;

    def tagIterator(ch:Seq[scala.xml.Node]):Iterator[Int] = new Iterator[Int] {
      val it = ch.elements.buffered;
      def hasNext = { 
        while (it.hasNext &amp;&amp; it.head.typeTag$ &lt; 0) it.next; 
        it.hasNext
      }
      def next = {
        if( hasNext ) {
          val n = it.next;
          val i = n.typeTag$;
          if( i > 0 ) i else $tagMap.get( n.label ) match {
            case Some( j ) => j
            case None      => 0
          }
        } else {
          error("internal error");
        }
      }
    }
    private val $tagMap = new mutable.HashMap[String,Int];
    <elementBinding>
     val $TagOf&ccElementName;:int = <elementTag/>;
     $tagMap.update( &qElementName;, $TagOf&ccElementName; );
     def constr_&ccElementName;( attrs:aT, ch:cT ) = &ccElementName;(attrs,ch:_*);

     case class &ccElementName;( attrs:Map[String,String], ch:scala.xml.Node* ) extends <string ref="objectName"/>Node$ {


    final override def typeTag$ = $TagOf&ccElementName;;

    final def shallowValidate&ccElementName;Children( ch:Seq[scala.xml.Node] ) = 
      <shallowContentRegExp/>;

    final def validateAttributes( attrs:Map[String,String] ):aT = {
        var req = 0;
        var map = scala.xml.Node.NoAttributes;
        <initAttributes/>
    
        for( val b &lt;- attrs.elements ) {
          val a:Seq[Char] = b._1;
          a match {
          <validateAttributes/>
            case _ => error_UndefinedAttribute( b._1 )
          }
        }
        if( req > 0 ) error_MissingAttribute( map );
        map
    }

    if( !shallowValidate&ccElementName;Children( ch ) )
       error("trying to construct invalid &elementName;");

     final def label = &qElementName;;
     final def child = ch;

      protected var hmap:aT = _;
      try {
        hmap = validateAttributes( attrs );
        } catch {
        case e:java.lang.Error => 
          error("trying to construct invalid &elementName;\n"+e.getMessage());
      }
      final def attribute:aT = hmap;

      <attributeBinding>
        final def &cAttributeName; : scala.Option[String] = hmap.get(&qAttributeName;);
      </attributeBinding>
      val attribHashCode: int = hmap.toList.hashCode() ;

     /** returns a new &ccElementName; with updated attributes */
     final def %(attrs: Seq[Pair[String, String]]) = {
       var newmap = scala.xml.Node.NoAttributes;
       for( val p &lt;- attribute.elements ) { 
          newmap = newmap.update( p._1, p._2 )
       }
       for( val p &lt;- attrs ) { 
          newmap = newmap.update( p._1, p._2 )
       }
       &ccElementName;( newmap, child:_* ) ;
     }
  
     /** returns a new &ccElementName; with updated attribute */
     final def %(attr: Pair[String, String])  = {
       var newmap = scala.xml.Node.NoAttributes;
       for( val p &lt;- attribute.elements ) { 
          newmap = newmap.update( p._1, p._2 );
       };
       newmap = newmap.update( attr._1, attr._2 );
       &ccElementName;( newmap, child:_* ) ;
     }
    }
    </elementBinding>
    

    def load( filename:String ):scala.xml.Node = load( filename, <string ref="compressDefault"/> );

    def load( filename:String, _compress:boolean ):scala.xml.Node = {
      val fAdapter = new scala.xml.BindingFactoryAdapter  {
        val f = { 
          val res = new mutable.HashMap[String, (aT,cT) => scala.xml.Node]() ;
          <elementBinding>
          res.update( &qElementName;, constr_&ccElementName;);</elementBinding>
          res;
        }

        val g = { 
          val res = new mutable.HashMap[String, boolean]() ;
          <elementBinding>
          res.update( &qElementName;, <string ref="elementContainsText"/>);</elementBinding>
          res;
        }
        val compress = _compress ; 
      };
      fAdapter.loadXML( new org.xml.sax.InputSource(filename) );
    };    
}
</template>
