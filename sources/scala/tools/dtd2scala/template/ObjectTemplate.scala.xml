<!DOCTYPE template [ 
  <!ENTITY elementName   '<string ref="elementName"/>'> 
  <!ENTITY qElementName  '<qstring ref="elementName"/>'> 
  <!ENTITY ccElementName '<ccstring ref="elementName"/>'> 
  <!ENTITY elementContentModel   '<string ref="elementContentModel"/>'> 
  <!ENTITY attributeName   '<string ref="attributeName"/>'> 
  <!ENTITY qAttributeName  '<qstring ref="attributeName"/>'> 
  <!ENTITY cAttributeName '<cstring ref="attributeName"/>'> 
  <!ENTITY space '<![CDATA[ ]]>'> 
  <!ENTITY br ''> 
]>
<!-- generalize to abstract syntax instead of concrete ? -->
<!-- the formatting should be done by a code beautifier -->
<template>
  /* this file is generated from a DTD using ObjectTemplate.scala.xml */
  <!-- package/ -->
  
  /** the following elements are bound
  <elementBinding>
    * &elementName; : &elementContentModel; {<attributeBinding>&attributeName;</attributeBinding>&space;}
  </elementBinding>
  **/
  
  object <string ref="objectName"/> {

    import scala.collection.Map;
    import scala.collection.immutable;
    import scala.collection.mutable;


    type cT = scala.Seq[scala.xml.Node];
    type aT = Map[String,String];

    abstract class <string ref="objectName"/>Node$ extends scala.xml.Node;

    <elementBinding>
      val $TagOf&ccElementName;:int = <elementTag/>;
    def constr_&ccElementName;( ch:cT, attrs:aT ) = new &ccElementName;(ch:_*) { 
      override var hmap = attrs;
      override val attribHashCode = attrs.toList.hashCode() ;
    };

    def shallowValidate&ccElementName;Children( ch:Seq[scala.xml.Node] ) = 
      <shallowContentRegExp/>;

    
     case class &ccElementName;( ch:scala.xml.Node* ) extends <string ref="objectName"/>Node$ {

       final override def typeTag$ = $TagOf&ccElementName;;

     if( !shallowValidate&ccElementName;Children( ch ) )
       error("trying to construct invalid &elementName;");

     def label = &qElementName;;
     def child = ch;

      protected var hmap:aT = scala.xml.Node.NoAttributes;
      final def attribute:aT = hmap;

      <attributeBinding>
        final def &cAttributeName; : scala.Option[String] = hmap.get(&qAttributeName;);
      </attributeBinding>
      val attribHashCode: int = hmap.toList.hashCode() ;

     /** returns a new &ccElementName; with updated attributes */
     final def %(attrs: Seq[Pair[String, String]]) = {
       var newmap = scala.xml.Node.NoAttributes;
       for( val p &lt;- attribute.elements ) { 
          newmap = newmap.update( p._1, p._2 )
       }
       for( val p &lt;- attrs ) { 
          newmap = newmap.update( p._1, p._2 )
       }
       constr_&ccElementName;( child, newmap ) ;
     }
  
     /** returns a new &ccElementName; with updated attribute */
     final def %(attr: Pair[String, String])  = {
       var newmap = scala.xml.Node.NoAttributes;
       for( val p &lt;- attribute.elements ) { 
          newmap = newmap.update( p._1, p._2 );
       };
       newmap = newmap.update( attr._1, attr._2 );
       constr_&ccElementName;( child, newmap ) ;
     }
    }
    </elementBinding>
    

    def load( filename:String ):scala.xml.Node = load( filename, <string ref="compressDefault"/> );

    def load( filename:String, _compress:boolean ):scala.xml.Node = {
      val fAdapter = new scala.xml.BindingFactoryAdapter  {
        val f = { 
          val res = new mutable.HashMap[String, (cT,aT) => scala.xml.Node]() ;
          <elementBinding>
          res.update( &qElementName;, (x:cT,aMap:aT) => constr_&ccElementName;(x,aMap));</elementBinding>
          res;
        }

        val g = { 
          val res = new mutable.HashMap[String, boolean]() ;
          <elementBinding>
          res.update( &qElementName;, <string ref="elementContainsText"/>);</elementBinding>
          res;
        }
        val compress = _compress ; 
      };
      fAdapter.loadXML( new org.xml.sax.InputSource(filename) );
    };    
}
</template>
