<!DOCTYPE template [ 
  <!ENTITY elementName   '<string ref="elementName"/>'> 
  <!ENTITY qElementName  '<qstring ref="elementName"/>'> 
  <!ENTITY ccElementName '<ccstring ref="elementName"/>'> 
  <!ENTITY elementContentModel   '<string ref="elementContentModel"/>'> 
  <!ENTITY attributeName   '<string ref="attributeName"/>'> 
  <!ENTITY qAttributeName  '<qstring ref="attributeName"/>'> 
  <!ENTITY cAttributeName '<cstring ref="attributeName"/>'> 
  <!ENTITY space '<![CDATA[ ]]>'> 
  <!ENTITY br ''> 
]>
<!-- generalize to abstract syntax instead of concrete ? -->
<!-- the formatting should be done by a code beautifier -->
<template>
  /* this file is generated from a DTD using ObjectTemplate.scala.xml */
  <!-- package/ -->
  
  /** the following elements are bound
  <elementBinding>
    * &elementName; : &elementContentModel; {<attributeBinding>&attributeName;</attributeBinding>&space;}
  </elementBinding>
  **/
  
  object <string ref="objectName"/> {

    import scala.collection.mutable.HashMap;

    type childrenT = scala.Seq[scala.xml.Node];
    type attribMap  = scala.collection.immutable.Map[String,String];
    type attribMapT = HashMap[String,String];
    type NodeConstructorType = (childrenT,attribMapT) =&gt; scala.xml.Node;

    <elementBinding>
    def constr_&ccElementName;( ch:childrenT, attrs:attribMapT ) = new &ccElementName;(ch:_*) { 
      private val hmap = attrs;
      override def attribute = attrs.toList;

    };
    
     case class &ccElementName;( ch:scala.xml.Node* ) extends scala.xml.Node {
     
     def label = &qElementName;;
     def child = ch;

      private val hmap = new HashMap[String,String];
      override def attribute:Seq[Pair[String,String]] = Nil;
      <attributeBinding>
        def &cAttributeName; : scala.Option[String] = hmap.get(&qAttributeName;);
      </attributeBinding>
      val attribHashCode: int = hmap.toList.hashCode() ;

     /** returns a new &ccElementName; with updated attributes */
     final def %(attrs: Seq[Pair[String, String]]) = {
       val newmap = new HashMap[String,String]();
       for( val p &lt;- attribute.elements ) { newmap += p._1 -&gt; p._2 };
       for( val p &lt;- attrs )         { newmap += p._1 -&gt; p._2 };
       new &ccElementName;( child:_* ) {
         private val hmap = newmap;
         override def attribute = newmap.toList;
       }
     }
  
     /** returns a new &ccElementName; with updated attribute */
     final def %(attr: Pair[String, String])  = {
       val newmap = new HashMap[String,String]();
       for( val p &lt;- attribute.elements ) { newmap += p._1 -&gt; p._2 };
       newmap += attr._1 -&gt; attr._2;
       new &ccElementName;( child:_* ) {
         private val hmap = newmap;
         override def attribute = newmap.toList;
       }
     }
    }
    </elementBinding>
    

    def load( filename:String ):scala.xml.Node = load( filename, <string ref="compressDefault"/> );

    def load( filename:String, _compress:boolean ):scala.xml.Node = {
      val fAdapter = new scala.xml.BindingFactoryAdapter  {
        val f = { 
          val res = new scala.collection.mutable.HashMap[String, NodeConstructorType] ;
          <elementBinding>
          res.update( &qElementName;, (x:childrenT,aMap:attribMapT) => constr_&ccElementName;(x,aMap));</elementBinding>
          res;
        }

        val g = { 
          val res = new scala.collection.mutable.HashMap[String, boolean] ;
          <elementBinding>
          res.update( &qElementName;, <string ref="elementContainsText"/>);</elementBinding>
          res;
        }
        val compress = _compress ; 
      };
      fAdapter.loadXML( new org.xml.sax.InputSource(filename) );
    };    
}
</template>
