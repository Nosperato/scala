#!/bin/sh
##############################################################################
#                      __                                                    #
#      ________ ___   / /  ___     Scala Tools Launch Script                 #
#     / __/ __// _ | / /  / _ |    (c) 2002-2003, LAMP/EPFL                  #
#   __\ \/ /__/ __ |/ /__/ __ |                                              #
#  /____/\___/_/ |_/____/_/ | |                                              #
#                           |/                                               #
##############################################################################

# $Id$

##############################################################################
# Configuration

# The configure function contains all the configurable variables of
# this script. The content of these variables may be overridden by
# defining an environment variable with the same name prefixed by
# SCALA_. For example, to run socos with a big initial heap size, one
# may run the command "env SCALA_JAVA_ARGS=-Xms1024m socos".
#
# The following environment variables are also read by this script:
# - SCALA_BOOTCLASSPATH: if defined, it is used as the default
#   bootclasspath by the Scala compiler.
#
# - SCALA_CLASSPATH: if defined, it is used as the default classpath
#   by the scala compiler.
#
# - CLASSPATH: if defined and if SCALA_CLASSPATH is undefined, it is
#   used as the default classpath by the Scala compiler.
#
# All paths and path lists must be in Unix form (i.e. use '/' as file
# separator and ':' as path separator). There is only one exception to
# this rule: CLASSPATH must be in Windows form (i.e. use '\' and ';')
# on Windows platforms.

configure() {

    # Location of the Scala library sources. These sources are
    # included in the Scala distribution.
    # This variable must refer a directory.
    RUNTIME_SOURCES={#RUNTIME_SOURCES#};

    # Location of the compiled Scala library. This library is included
    # in the Scala distribution.
    # This variable must refer a directory or a zip or jar file.
    RUNTIME_CLASSES={#RUNTIME_CLASSES#};

    # Location of the compiled Scala tools. These tools are included
    # in the Scala distribution.
    # This variable must refer a directory or a zip or jar file.
    TOOLS_CLASSES={#TOOLS_CLASSES#};

    # Location of the compiled fjbg library.  This library is included
    # in the Scala distribution.
    # This variable must refer a directory or a zip or jar file.
    FJBG_CLASSES={#FJBG_CLASSES#};

    # Location of the compiled msil library. This library is included
    # in the Scala distribution.
    # This variable must refer a directory or a zip or jar file.
    MSIL_CLASSES={#MSIL_CLASSES#};

    # Command to start the Java VM.
    JAVA_EXEC="java";

    # Additional arguments to pass to the Java VM.
    JAVA_ARGS={#JAVA_ARGS#};

    # Command to start subprocesses. This is mainly for debugging
    # purposes. One may, for example, display the Java command that is
    # started by "socos", by running "env SCALA_EXEC=echo socos".
    EXEC="exec";

}

##############################################################################
# Error functions

# Prints a warning message on stderr.
warning() {
    echo "$0: warning:" "$@" 1>&2;
}

# Prints an error message on stderr.
error() {
    echo "$0:" "$@" 1>&2;
}

# Prints an error message on stderr and exits with a non-zero status.
abort() {
    error "$@";
    exit 1;
}

##############################################################################
# File name and path list conversion functions

# Prints the OS specific form of the given Unix form file name.
get_os_filename() {
    [ $# = 1 ] || abort "internal error";
    case "$UNAME" in
        CYGWIN* ) cygpath --windows "$1";;
        *       ) echo "$@";;
    esac;
}

# Prints the OS specific form of the given Unix form path list.
get_unix_filename() {
    [ $# = 1 ] || abort "internal error";
    case "$UNAME" in
        CYGWIN* ) cygpath --unix "$1";;
        *       ) echo "$@";;
    esac;
}

# Prints the Unix form of the given OS specific form file name.
get_os_pathlist() {
    [ $# = 1 ] || abort "internal error";
    case "$UNAME" in
        CYGWIN* ) cygpath --window --path "$1";;
        *       ) echo "$@";;
    esac;
}

# Prints the Unix form of the given OS specific form path list.
get_unix_pathlist() {
    [ $# = 1 ] || abort "internal error";
    case "$UNAME" in
        CYGWIN* ) cygpath --unix --path "$1";;
        *       ) echo "$@";;
    esac;
}

##############################################################################
# Variable configuration functions

# Configures the variable with the given name. If a variable named
# SCALA_$1 is defined, assigns its value to the variable named $1,
# otherwise does nothing.
configure_variable() {
    [ $# = 1 ] || abort "internal error";

    if set | grep "^SCALA_$1=" > /dev/null; then
        eval $1=\$SCALA_$1;
    fi;
}

# Configures and tests the path variable with the given name. If a
# variable named SCALA_$1 is defined and refers an existing directory
# or file, assigns its value to the variable named $1. If, after that,
# the variable $1 refers a non-existing path, exits with an error.
configure_path_variable() {
    [ $# = 1 ] || abort "internal error";

    if set | grep "^SCALA_$1=" > /dev/null; then
        path=`eval echo \\\$SCALA_\$1`;
        if [ -f "$path" -o -d "$path" ]; then
            eval $1=\$SCALA_$1;
        else
            warning "File refered by SCALA_$1 ($path) does not exist.";
            unset SCALA_$1;
        fi;
    fi;

    path=`eval echo \\\$\$1`;
    if [ ! -f "$path" -a ! -d "$path" ]; then
        abort "File referred by $1 ($path) does not exist." \
            "Please, fix the definition of $1 in file $SOURCE." \
            "Alternatively you may also define the environment" \
            "variable SCALA_$1.";
    fi
}

##############################################################################
# Path list construction functions

# Prepends a named path to a named path list. First, computes variable
# $2 and then updates the path list in variable $1 by appending the
# path from variable $2.
prepend_path() {
    [ $# = 2 ] || abort "internal error";

    compute_variable "$2";

    if [ -z "`eval echo \\\$\$1`" ]; then
        eval $1=\$$2;
    else
        eval $1=\$$2:\$$1;
    fi;
}

##############################################################################
# Variable computation functions

# Sets SCALA_CLASSPATH to its default value.
compute_default_scala_classpath() {
    SCALA_CLASSPATH=".";
}

# Computes SCALA_CLASSPATH.
compute_scala_classpath() {
    if [ -z "$SCALA_CLASSPATH" ]; then
        if [ -n "$CLASSPATH" ]; then
            SCALA_CLASSPATH=`get_unix_pathlist "$CLASSPATH"`;
        else
            compute_default_scala_classpath;
        fi;
    fi;
}

# Sets SCALA_BOOTCLASSPATH to its default value.
compute_default_scala_bootclasspath() {
    eval SCALA_BOOTCLASSPATH="";
    prepend_path SCALA_BOOTCLASSPATH RUNTIME_SOURCES;
    prepend_path SCALA_BOOTCLASSPATH RUNTIME_CLASSES;
}


# Computes SCALA_BOOTCLASSPATH.
compute_scala_bootclasspath() {
    if [ -z "$SCALA_BOOTCLASSPATH" ]; then
        compute_default_scala_bootclasspath;
    fi;
}

# Computes variable $1.
compute_variable() {
    [ $# = 1 ] || abort "internal error";

    case "$1" in
        SCALA_CLASSPATH     ) compute_scala_classpath;;
        SCALA_BOOTCLASSPATH ) compute_scala_bootclasspath;;
        RUNTIME_SOURCES     ) configure_path_variable "$1";;
        RUNTIME_CLASSES     ) configure_path_variable "$1";;
        TOOLS_CLASSES       ) configure_path_variable "$1";;
        FJBG_CLASSES        ) configure_path_variable "$1";;
        MSIL_CLASSES        ) configure_path_variable "$1";;
        JAVA_EXEC           ) configure_variable "$1";;
        JAVA_ARGS           ) configure_variable "$1";;
        EXEC                ) configure_variable "$1";;
    esac;
}

##############################################################################
# Java invocation functions

# Starts a Java program with the given arguments and the following
# additional ones:
# - arguments specified by the variable JAVA_ARGS
# - script-suffix-specific arguments
exec_java() {
    [ $# -gt 0 ] || abort "internal error";

    # configure variables
    compute_variable EXEC;
    compute_variable JAVA_EXEC;
    compute_variable JAVA_ARGS;

    # append script-suffix-specific arguments
    case "$SCRIPT" in
        *-debug* ) JAVA_ARGS="$JAVA_ARGS -Djava.compiler=NONE";;
    esac;

    # invoke Java
    $EXEC $JAVA_EXEC $JAVA_ARGS "$@";
}

# Starts a Scala tool. The first argument must be either "java" or
# "scala". It tells whether the tool is written in Java or Scala. The
# following arguments are passed to exec_java. They must, at least,
# contain the name of the main class.
exec_tool() {
    [ $# -gt 1 ] || abort "internal error";
    language="$1"; shift 1;

    # augment Java classpath
    prepend_path JAVA_CLASSPATH TOOLS_CLASSES;
    case "$language" in
        java  ) true;;
        scala ) prepend_path JAVA_CLASSPATH RUNTIME_CLASSES;;
        *     ) abort "internal error: found language='$language'";;
    esac;

    # invoke Java
    exec_java \
        -classpath "`get_os_pathlist "$JAVA_CLASSPATH"`" \
        -Dscala.home="$PREFIX" \
        -Dscala.product="$SCRIPT" \
        -Dscala.version="$VERSION" \
        "$@";
}

# Starts a Scala compile tool (one that uses properties
# scala.class.path and scala.boot.class.path). The first argument must
# be either "java" or "scala". It tells whether the tool is written in
# Java or Scala. The following arguments are passed to exec_java. They
# must, at least, contain the name of the main class.
exec_compile_tool() {
    [ $# -gt 1 ] || abort "internal error";
    language="$1"; shift 1;

    # compute Scala classpath and bootclasspath
    compute_scala_classpath;
    compute_scala_bootclasspath;

    # invoke Java
    exec_tool "$language" \
        -Dscala.class.path=`get_os_pathlist "$SCALA_CLASSPATH"` \
        -Dscala.boot.class.path=`get_os_pathlist "$SCALA_BOOTCLASSPATH"` \
        "$@";
}

# Starts a Scala compiler. The first argument must be either "java" or
# "scala". It tells whether the tool is written in Java or Scala. The
# following arguments are passed to exec_java. They must, at least,
# contain the name of the main class.
exec_compiler() {
    [ $# -gt 1 ] || abort "internal error";
    language="$1"; shift 1;

    # augment Java classpath
    prepend_path JAVA_CLASSPATH MSIL_CLASSES;
    prepend_path JAVA_CLASSPATH FJBG_CLASSES;

    exec_compile_tool "$language" "$@";
}

##############################################################################
# Implementation of scala-info

# Prints given error message, prints usage and exits with error code 1.
scala_info_abort() {
    error "$@";
    scala_info_print_usage 1>&2;
    exit 1;
}

# Prints value of $1.
scala_info_print_variable() {
    [ $# = 1 ] || abort "internal error";
    eval echo \"\$$1\";
}

# Prints default value of $1.
scala_info_print_variable_default() {
    [ $# = 1 ] || abort "internal error";
    case "$1" in
        SCALA_CLASSPATH     ) compute_default_scala_classpath;;
        SCALA_BOOTCLASSPATH ) compute_default_scala_bootclasspath;;
    esac;
    scala_info_print_variable "$1";
}

# Prints current value of $1.
scala_info_print_variable_current() {
    [ $# = 1 ] || abort "internal error";
    compute_variable "$1";
    scala_info_print_variable "$1";
}

# Implements "scala-info --home".
scala_info_option_home() {
    [ $# -gt 0 ] && abort "too many arguments";
    echo "$PREFIX";
}

# Implements "scala-info --$1 <variable>"
scala_info_option_x_variable() {
    [ $# -lt 2 ] && abort "missing variable name";
    [ $# -gt 2 ] && abort "too many arguments";
    case "$2" in
        CLASSPATH           ) variable=SCALA_$2;;
        BOOTCLASSPATH       ) variable=SCALA_$2;;
        RUNTIME_SOURCES     ) variable=$2;;
        RUNTIME_CLASSES     ) variable=$2;;
        TOOLS_CLASSES       ) variable=$2;;
        FJBG_CLASSES        ) variable=$2;;
        MSIL_CLASSES        ) variable=$2;;
        JAVA_EXEC           ) variable=$2;;
        JAVA_ARGS           ) variable=$2;;
        EXEC                ) variable=$2;;
        *                   ) abort "Unknown variable \`$2'";;
    esac;
    scala_info_print_variable_$1 $variable;
}

# Implements "scala-info --help".
scala_info_option_help() {
    echo "usage: $0 <option>";
    echo "where possible options include:";
    echo "  --home                Print Scala home directory";
    echo "  --default <variable>  Print default value of variable";
    echo "  --current <variable>  Print current value of variable";
    echo "  -? --help             Print this help message";
    echo "";
    echo "valid variables include:";
    echo "  CLASSPATH             Default classpath";
    echo "  BOOTCLASSPATH         Default bootclasspath";
    echo "  RUNTIME_SOURCES       Location of the Scala library sources";
    echo "  RUNTIME_CLASSES       Location of the Scala library";
    echo "  TOOLS_CLASSES         Location of the Scala tools";
    echo "  FJBG_CLASSES          Location of the fjbg library";
    echo "  MSIL_CLASSES          Location of the msil library";
    echo "  JAVA_EXEC             Command to start the Java VM";
    echo "  JAVA_ARGS             Additional arguments to pass to the Java VM";
    echo "  EXEC                  Command to start subprocesses";
}

# Entry point of scala-info.
scala_info() {
    [ $# = 0 ] && abort "missing option";

    case "$1" in
        --home      ) shift 1; scala_info_option_home "$@";;
        --default   ) shift 1; scala_info_option_x_variable default "$@";;
        --current   ) shift 1; scala_info_option_x_variable current "$@";;
        -? | --help ) shift 1; scala_info_option_help "$@";;
        -*          ) abort "unrecognised option \`$1'";;
        *           ) abort "illegal argument \`$1'";;
    esac;
}

##############################################################################
# Implementation of scala

# Returns true if the given arguments contain a Xbootclasspath: flag.
scala_has_bootclasspath() {
    while [ $# != 0 ]; do
        case "$1" in
            -Xbootclasspath:* ) return 0;;
            -cp | -classpath  ) shift 2;;
            -jar              ) return 1;;
            -*                ) shift 1;;
            *                 ) return 1;;
        esac;
    done;
    return 1;
}

# Entry point of scala-info.
scala() {
    compute_variable EXEC;
    if scala_has_bootclasspath "$@"; then
        exec_java "$@";
    else
        compute_variable RUNTIME_CLASSES;
        exec_java "-Xbootclasspath/a:$RUNTIME_CLASSES" "$@";
    fi;
}

##############################################################################
# Definition of UNAME, SOURCE, SCRIPT, PREFIX and VERSION

unset SCRIPT;
UNAME=`uname`;
SOURCE=$0;
SCRIPT=`basename "$SOURCE"`;
while [ -h "$SOURCE" ]; do
    SCRIPT=`basename "$SOURCE"`;
    LOOKUP=`ls -ld "$SOURCE"`;
    TARGET=`expr "$LOOKUP" : '.*-> \(.*\)$'`;
    if expr "${TARGET:-.}/" : '/.*/$' > /dev/null; then
        SOURCE=${TARGET:-.};
    else
        SOURCE=`dirname "$SOURCE"`/${TARGET:-.};
    fi;
done;
PREFIX=`dirname "$SOURCE"`/..;
PREFIX=`cd "$PREFIX"; pwd`;

VERSION={#VERSION#};
VERSION=${VERSION:-"unknown version"};

##############################################################################
# Test of invocation method

if [ -z "$SCRIPT" ]; then
    abort "Illegal direct invocation; invoke me through a symbolic link.";
fi;

##############################################################################
# Configuration and invocation of $SCRIPT

unset JAVA_CLASSPATH;
configure;

case "$SCRIPT" in
    scala      ) scala "$@";;
    scala-info ) scala_info "$@";;
    scalacboot*) exec_compiler java scalac.Main "$@";;
    scalac*    ) exec_compiler scala scala.tools.scalac.Main "$@";;
    scalarun*  ) exec_compiler scala scala.tools.scalai.Main "$@";;
    scalaint*  ) exec_compiler scala scala.tools.scalai.Main -interactive "$@";;
    scaladoc*  ) exec_compile_tool scala scala.tools.scaladoc.Main "$@";;
    scalap*    ) exec_compile_tool scala scala.tools.scalap.Main "$@";;
    dtd2scala* ) exec_tool scala scala.tools.dtd2scala.Main "$@";;
    scalatest* ) exec_tool java scala.tools.scalatest.Main "$@";;
    *          ) abort "Don't know what to do for $SCRIPT.";;
esac;

##############################################################################
