\appendix
\chapter{Scala Syntax Summary}

The lexical syntax of Scala is given by the following grammar in EBNF
form.

\begin{lstlisting}
  upper          ::=  `A' | $\ldots$ | `Z' | `$\Dollar$' | `_' $\mbox{\rm\em and Unicode Lu}$
  lower          ::=  `a' | $\ldots$ | `z' $\mbox{\rm\em and Unicode Ll}$
  letter         ::=  upper | lower $\mbox{\rm\em and Unicode categories Lo, Lt, Nl}$
  digit          ::=  `0' | $\ldots$ | `9'
  special        ::=  $\mbox{\rm\em ``all other characters in \U{0020-007F} and Unicode categories Sm, So}$
                      $\mbox{\rm\em except parentheses ([{}]) and periods''}$

  op             ::=  special {special} 
  varid          ::=  lower {letter | digit} [`_' {digit} [id]]
  id             ::=  upper {letter | digit} [`_' {digit} [id]]
                   | varid
                   | op
                   | `\'stringLit

  intLit         ::=  $\mbox{\rm\em ``as in Java''}$
  floatLit       ::=  $\mbox{\rm\em ``as in Java''}$
  charLit        ::=  $\mbox{\rm\em ``as in Java''}$
  stringLit      ::=  $\mbox{\rm\em ``as in Java''}$
  symbolLit      ::= `\'' id

  comment        ::=  `/*' ``any sequence of characters'' `*/'
                   |  `//' `any sequence of characters up to end of line''
\end{lstlisting}

The context-free syntax of Scala is given by the following EBNF
grammar.

\begin{lstlisting}
  Literal        ::=  intLit
                   |  floatLit
                   |  charLit
                   |  stringLit
                   |  symbolLit
                   |  true
                   |  false
                   |  null

  StableId       ::=  id
                   |  Path `.' id
  Path           ::=  StableId
                   |  [id `.'] this
                   |  [id '.'] super [`[' id `]']`.' id

  Type           ::=  Type1 `=>' Type
                   |  `(' [Types] `)' `=>' Type
                   |  Type1
  Type1          ::=  SimpleType {with SimpleType} [Refinement]
  SimpleType     ::=  SimpleType TypeArgs
                   |  SimpleType `#' id
                   |  StableId
                   |  Path `.' type
                   |  `(' Type ')'
  TypeArgs        ::=  `[' Types `]'
  Types           ::=  Type {`,' Type}
  Refinement      ::=  `{' [RefineStat {`;' RefineStat}] `}'
  RefineStat      ::=  Dcl
                    |  type TypeDef
                    |

  Exprs           ::=  Expr {`,' Expr}
  Expr            ::=  Bindings `=>' Expr
                    |  Expr1
  Expr1           ::=  if `(' Expr1 `)' Expr [[`;'] else Expr]
                    |  try `{' Block `}' [catch Expr] [finally Expr]
                    |  do Expr [`;'] while `(' Expr ')'
                    |  for `(' Enumerators `)' (do | yield) Expr
                    |  return [Expr]
                    |  throw Expr
                    |  [SimpleExpr `.'] id `=' Expr
                    |  SimpleExpr ArgumentExprs `=' Expr
                    |  PostfixExpr [`:' Type1]
  PostfixExpr     ::=  InfixExpr [id]
  InfixExpr       ::=  PrefixExpr
                    |  InfixExpr id PrefixExpr
  PrefixExpr      ::=  [`-' | `+' | `~' | `!'] SimpleExpr 
  SimpleExpr      ::=  Literal
                    |  Path
                    |  `(' [Expr] `)'
                    |  BlockExpr
                    |  new Template 
                    |  SimpleExpr `.' id 
                    |  SimpleExpr TypeArgs
                    |  SimpleExpr ArgumentExprs
                    |  XmlExpr
  ArgumentExprs    ::=  `(' [Exprs] ')'
                    |  BlockExpr
  BlockExpr       ::=  `{' CaseClause {CaseClause} `}'
                    |  `{' Block `}'
  Block           ::=  {BlockStat `;'} [ResultExpr]
  BlockStat       ::=  Import
                    |  Def
                    |  {LocalModifier} TmplDef
                    |  Expr1
                    |
  ResultExpr      ::=  Expr1
                    |  Bindings `=>' Block

  Enumerators     ::=  Generator {`;' Enumerator}
  Enumerator      ::=  Generator
                    |  Expr
  Generator       ::=  val Pattern1 `<-' Expr

  CaseClause      ::=  case Pattern [`if' PostfixExpr] `=>' Block 

  Constr          ::=  StableId [TypeArgs] [`(' [Exprs] `)']  
  SimpleConstr    ::=  Id [TypeArgs] [`(' [Exprs] `)']  

  Pattern         ::=  Pattern1 { `|' Pattern1 }
  Pattern1        ::=  varid `:' Type
                    |  `_' `:' Type
                    |  Pattern2
  Pattern2        ::=  [varid `@'] Pattern3
  Pattern3        ::=  SimplePattern [ '*' | '?' | '+' ]
                    |  SimplePattern { id SimplePattern }
  SimplePattern   ::=  `_'
                    |  varid
                    |  Literal
                    |  StableId [ `(' [Patterns] `)' ]
                    |  `(' [Patterns] `)'
                    |  XmlPattern
  Patterns        ::=  Pattern {`,' Pattern}

  TypeParamClause ::=  `[' VarTypeParam {`,' VarTypeParam} `]'
  FunTypeParamClause ::=  `[' TypeParam {`,' TypeParam} `]'
  VarTypeParam    ::=  [`+' | `-'] TypeParam
  TypeParam       ::=  id [>: Type] [<: Type | <% Type]
  ParamClause     ::=  `(' [Param {`,' Param}] `)'
  Param           ::=  [def] id `:' Type [`*']
  Bindings        ::=  id [`:' Type1]
                    |  `(' Binding {`,' Binding `)'
  Binding         ::=  id [`:' Type]

  Modifier        ::=  LocalModifier
                    |  private
                    |  protected
                    |  override 
  LocalModifier   ::=  abstract
                    |  final
                    |  sealed

  Template        ::=  Constr {`with' Constr} [TemplateBody]
  TemplateBody    ::=  `{' [TemplateStat {`;' TemplateStat}] `}'
  TemplateStat    ::=   Import
                    |  {Modifier} Def
                    |  {Modifier} Dcl
                    |  Expr
                    |

  Import          ::=  import ImportExpr {`,' ImportExpr}
  ImportExpr      ::=  StableId `.' (id | `_' | ImportSelectors)
  ImportSelectors ::=  `{' {ImportSelector `,'} 
                       (ImportSelector | `_') `}'
  ImportSelector  ::=  id [`=>' id | `=>' `_']

  Dcl             ::=  val ValDcl
                    |  var VarDcl
                    |  def FunDcl
                    |  type TypeDcl

  ValDcl          ::=  id {`,' id} `:' Type
  VarDcl          ::=  id {`,' id} `:' Type
  FunDcl          ::=  FunSig {`,' FunSig} `:' Type
  FunSig          ::=  id [FunTypeParamClause] {ParamClause}
  TypeDcl         ::=  id [>: Type] [<: Type]

  Def             ::=  val PatDef
                    |  var VarDef
                    |  def FunDef
                    |  type TypeDef
                    |  TmplDef
  PatDef          ::=  Pattern2 {`,' Pattern2} [`:' Type] `=' Expr
  VarDef          ::=  id {`,' id} [`:' Type] `=' Expr
                    |  id {`,' id} `:' Type `=' `_'
  FunDef          ::=  FunSig {`,' FunSig} `:' Type `=' Expr
                    |  this ParamClause `=' ConstrExpr
  TypeDef         ::=  id [TypeParamClause] `=' Type

  TmplDef         ::=  ([case] class | trait) ClassDef
                    |  [case] object ObjectDef
  ClassDef        ::=  ClassSig {`,' ClassSig} [`:' SimpleType] ClassTemplate
  ClassSig        ::=  id [TypeParamClause] [ParamClause]
  ObjectDef       ::=  id {`,' id} [`:' SimpleType] ClassTemplate

  ClassTemplate   ::=  extends Template
                    |  TemplateBody
                    |
  ConstrExpr      ::=  this ArgumentExprs
                    |  `{' this ArgumentExprs {`;' BlockStat} `}'

  CompilationUnit ::=  [package QualId `;'] {TopStat `;'} TopStat
  TopStat         ::=  {Modifier} TmplDef
                    |  Import
                    |  Packaging
                    |
  Packaging       ::=  package QualId `{' {TopStat `;'} TopStat `}'
  QualId          ::=  id {`.' id}
\end{lstlisting}

\chapter{Implementation Status}

\input{ImplementationStatus}

\end{document}

